#!/usr/bin/perl

use strict;
use warnings;

#Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:
#Triangle 	  	P3,n=n(n+1)/2 	  	1, 3, 6, 10, 15, ...
#Square 	  	P4,n=n^2 	  	1, 4, 9, 16, 25, ...
#Pentagonal 	  	P5,n=n(3n-1)/2 	  	1, 5, 12, 22, 35, ...
#Hexagonal 	  	P6,n=n(2n-1) 	  	1, 6, 15, 28, 45, ...
#Heptagonal 	  	P7,n=n(5n-3)/2 	  	1, 7, 18, 34, 55, ...
#Octagonal 	  	P8,n=n(3n-2) 	  	1, 8, 21, 40, 65, ...
#
#The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
#
#  1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).
#  2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.
#  3. This is the only set of 4-digit numbers with this property.
#
#Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.

#main

my %polys;

my $i = 0;
while ( $i * ( $i + 1 ) / 2 < 10000 ) {
  $i++;
  my $p = $i * ( $i + 1 ) / 2;
  push( @{$polys{3}}, $p ) if ( length $p == 4 );
  $p = $i**2;
  push( @{$polys{4}}, $p ) if ( length $p == 4 );
  $p = $i * ( 3 * $i - 1 ) / 2;
  push( @{$polys{5}}, $p ) if ( length $p == 4 );
  $p = $i * ( 2 * $i - 1 );
  push( @{$polys{6}}, $p ) if ( length $p == 4 );
  $p = $i * ( 5 * $i - 3 ) / 2;
  push( @{$polys{7}}, $p ) if ( length $p == 4 );
  $p = $i * ( 3 * $i - 2 );
  push( @{$polys{8}}, $p ) if ( length $p == 4 );
} 

my %firsts;
for my $i ( sort keys %polys ) {
#  print "$i:\n", join(", ", @{$polys{$i}}), "\n\n";
  for my $num ( @{$polys{$i}} ) {
    $firsts{substr $num, 0, 2}{substr $num, 2, 2}{$i} = 1;
  }
}

#use Data::Dumper;
#print Dumper \%firsts;

my $used = { 3 => 1,
             4 => 0,
	     5 => 0,
	     6 => 0,
	     7 => 0,
	     8 => 0,
	     };
my $numbers = ();
for my $first ( @{$polys{3}} ) {
  push @$numbers, $first;
  find_next( $used, $numbers );
  pop @$numbers;
}

sub find_next {
  my ($used, $numbers) = @_;
  my @left;
  for ( keys %$used ) {
    push( @left, $_ ) unless $used->{$_};
  }
  my $last = substr $numbers->[-1], 2, 2;
  if ( @left == 1 ) {
    my $first = substr $numbers->[0], 0, 2;
    if ( $firsts{$last}{$first}{$left[0]} ) {
      my $sum = $last * 100 + $first;
      print "$sum, ";
      for my $i ( @$numbers ) {
        $sum += $i;
	print "$i, ";
      }
      print "sum = $sum\n";
    }
    return;
  } else {
    TRY: for my $try ( keys %{ $firsts{$last} } ) {
      for my $bin ( keys %{ $firsts{$last}{$try} } ) {
        next if $used->{$bin};
        push @$numbers, "$last$try";
	$used->{$bin} = 1;
	find_next( $used, $numbers );
	$used->{$bin} = 0;
        pop @$numbers;
      }
    }
  }
}
